<!DOCTYPE html>
<html>

<head>
  <title>dKanban Board</title>

  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no" />
  <meta httpEquiv="Pragma" content="no-cache" />
  <link rel="shortcut icon"
    href="https://raw.githubusercontent.com/estebanrfp/static-assets/master/dKanban/favicon.ico" />
  <link rel="stylesheet" href="./lib/styles.css">
  <!-- Component styles (loaded via link instead of JS imports) -->
  <link rel="stylesheet" href="./lib/components/Alerts/styles.css">
  <link rel="stylesheet" href="./lib/components/Modal/styles.css">
  <link rel="stylesheet" href="./lib/components/Spinner/styles.css">
  <link rel="stylesheet" href="./lib/components/Signing/styles.css">
  <link rel="stylesheet" href="./lib/components/Kanban/styles.css">
  <link rel="stylesheet" href="./lib/components/Kanban/colorPicker.css">
</head>

<body>
  <span id="pageMessages"></span>
  <div class="notifications"></div>
  <span class="spinner fadeout"></span>
  <div id="container" class="Layout"></div>
  <div id="modal" hidden>
    <div id="modalHeader">
      <h2 id="modalTitle"></h2>
      <button id="close-modal">&times;</button>
    </div>
    <div id="modalBody"></div>
  </div>
  <div id="sub-menu" hidden>
    <div id="submenuHeader">
      <h3 id="submenuTitle"></h3>
      <button id="close-col-menu">&times;</button>
    </div>
    <div id="submenuBody"></div>
  </div>
  <div id="overlay" class="hidden"></div>
  <!-- Single top-level module with all boot logic -->
  <script type="module">
    // Import ESM dependencies from CDNs
    import { gdb } from 'https://cdn.jsdelivr.net/npm/genosdb@latest/dist/index.min.js'
    import { marked } from 'https://cdn.jsdelivr.net/npm/marked@12.0.1/lib/marked.esm.js'

    // Lazy-load local components only when needed
    const mount = document.querySelector('.Layout')

    // Initialize database once, enabling SM (RTC required)
    const db = await gdb('dkanban', {
      rtc: true,
      sm: {
        // NOTE: replace with your admin addresses
        superAdmins: ['0xE5639DfE345F8ab845bEBE63a1C7322F9c6fF5c7'],
        customRoles: {
          superadmin: { can: ["assignRole", "deleteAny"], inherits: ["admin"] },
          admin: { can: ["delete"], inherits: ["manager"] },
          manager: { can: ["publish"], inherits: ["user"] },
          user: { can: ["write"], inherits: ["guest"] },
          guest: { can: ["read", "sync", "write"] },  // "write" added temporarily for testing guest permissions
        }
      }
    })

    const loadKanban = async (state = {}) => {
      const { default: mountKanban } = await import('./lib/components/Kanban/index.js')
      await mountKanban({ db, mount, marked, onLogout: loadSigning, state })
    }

    const loadSigning = async () => {
      const { default: mountSigning } = await import('./lib/components/Signing/index.js')
      await mountSigning({ db, mount, onAuthenticated: (identity) => {
        const abbrAddr = identity?.address ? `${ identity.address.slice(0,6) }…${ identity.address.slice(-4) }` : undefined
        loadKanban({ abbrAddr })
      } })
    }

    // Helpers for WebAuthn auto-login
    const toBase64Url = buffer => {
      const bytes = new Uint8Array(buffer)
      let binary = ''
      for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i])
      return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '')
    }
    const fromBase64Url = (str) => {
      const pad = '='.repeat((4 - (str.length % 4)) % 4)
      const base64 = (str + pad).replace(/-/g, '+').replace(/_/g, '/')
      const raw = atob(base64)
      const out = new Uint8Array(raw.length)
      for (let i = 0; i < raw.length; i++) out[i] = raw.charCodeAt(i)
      return out.buffer
    }
    const abbr = addr => addr ? `${ addr.slice(0,6) }…${ addr.slice(-4) }` : ''

    async function tryAutoLoginWithWebAuthn () {
      if (!('credentials' in navigator) || !('PublicKeyCredential' in window)) return null
      // Collect known WebAuthn records from localStorage
      let rawId = localStorage.getItem('webauthn-last')
      let record = rawId ? JSON.parse(localStorage.getItem(`webauthn-${rawId}`) || 'null') : null
      if (!record) {
        // Fallback: scan localStorage for any webauthn-* record
        for (let i = 0; i < localStorage.length; i++) {
          const k = localStorage.key(i)
          if (k && k.startsWith('webauthn-') && !k.startsWith('webauthn-mnemonic-') && k !== 'webauthn-last') {
            try { record = JSON.parse(localStorage.getItem(k) || 'null') } catch (_) { record = null }
            if (record && record.rawId) { rawId = record.rawId; break }
          }
        }
      }
      if (!record || !rawId) return null
      // Build a simple assertion request against the saved credential id
      const challenge = new Uint8Array(32); crypto.getRandomValues(challenge)
      const allowCredentials = [{ type: 'public-key', id: fromBase64Url(rawId) }]
      try {
        const assertion = await navigator.credentials.get({ publicKey: { challenge, allowCredentials, userVerification: 'preferred' } })
        if (!assertion) return null
        // Retrieve stored mnemonic and login
        const mnemonic = localStorage.getItem(`webauthn-mnemonic-${rawId}`)
        if (!mnemonic) return null
        try {
          const identity = await db.sm.loginOrRecoverUserWithMnemonic(mnemonic)
          return identity
        } catch (_) {
          return null
        }
      } catch (_) {
        return null
      }
    }

    // Decide first screen based on security/session state + WebAuthn auto-login
    if (db.sm && db.sm.isSecurityActive()) {
      await loadKanban()
    } else {
      const identity = await tryAutoLoginWithWebAuthn()
      if (identity?.address) {
        await loadKanban({ abbrAddr: abbr(identity.address) })
      } else {
        await loadSigning()
      }
    }
  </script>
</body>

</html>